<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ACSM Converter</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <style>
        :root {
            --pico-font-size: 16px;
            --accent: #4a90d9;
            --accent-hover: #357abd;
        }
        body { background: #f4f6f9; }
        header.hero {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            padding: 2.5rem 0;
            margin-bottom: 2rem;
            text-align: center;
        }
        header.hero h1 { color: #fff; margin-bottom: 0.25rem; }
        header.hero p { color: #a0b4cc; margin: 0; }

        .upload-box {
            background: #fff;
            border-radius: 12px;
            padding: 2.5rem 2rem;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 2rem;
        }
        .upload-box .icon { font-size: 2.5rem; margin-bottom: 0.75rem; }
        .upload-box p { color: #546e7a; margin-bottom: 1.25rem; }
        .btn-browse {
            display: inline-block;
            padding: 0.6rem 1.75rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            background: var(--accent);
            border: none;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-browse:hover { background: var(--accent-hover); }

        .book-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 1.5rem;
        }
        .book-card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
            display: flex;
            flex-direction: row;
            transition: box-shadow 0.2s;
        }
        .book-card:hover { box-shadow: 0 4px 16px rgba(0,0,0,0.14); }
        .book-cover {
            width: 120px;
            min-height: 160px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden;
        }
        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .book-cover .placeholder {
            font-size: 2.5rem;
            color: #9e9e9e;
        }
        .book-info {
            padding: 1rem 1.25rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
            min-width: 0;
        }
        .book-info h4 {
            margin: 0 0 0.75rem 0;
            font-size: 1.05rem;
            word-break: break-word;
        }
        .book-files { display: flex; flex-direction: column; gap: 0.4rem; }
        .book-file {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }
        .file-badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.03em;
        }
        .file-badge.epub { background: #e8f5e9; color: #2e7d32; }
        .file-badge.pdf { background: #fce4ec; color: #c62828; }
        .file-size { color: #78909c; font-size: 0.85rem; }
        .btn-dl {
            display: inline-block;
            padding: 0.3rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            color: #fff;
            background: var(--accent);
            transition: background 0.2s;
            white-space: nowrap;
        }
        .btn-dl:hover { background: var(--accent-hover); color: #fff; }

        .btn-convert-epub {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.85rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            color: #2e7d32;
            background: #e8f5e9;
            border: 1px solid #a5d6a7;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }
        .btn-convert-epub:hover { background: #c8e6c9; }
        .btn-convert-epub:disabled { opacity: 0.6; cursor: default; }

        .epub-converting {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #546e7a;
        }
        .epub-converting .mini-spinner {
            display: inline-block;
            width: 14px; height: 14px;
            border: 2px solid var(--accent);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        .btn-stop {
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            color: #c62828;
            background: #fce4ec;
            border: 1px solid #ef9a9a;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-stop:hover { background: #ffcdd2; }

        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
        .step { padding: 0.3rem 0; }
        .step[data-status="active"] { font-weight: bold; }
        .step[data-status="done"]::before { content: "\2713 "; color: #2e7d32; }
        .step[data-status="active"]::before {
            content: "";
            display: inline-block;
            width: 14px; height: 14px;
            border: 2px solid var(--accent);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }
        .step[data-status="error"]::before { content: "\2717 "; color: #c62828; }
        .step .elapsed {
            font-weight: normal;
            font-size: 0.8rem;
            color: #78909c;
            margin-left: 0.5rem;
        }
        #confirm-section, #progress-section { display: none; }
        #confirm-section, #progress-section {
            background: #fff;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 2rem;
        }
        section h3 { margin-top: 0; }
        .confirm-filename { font-weight: 600; word-break: break-all; }
        .confirm-buttons { display: flex; gap: 1rem; margin-top: 1rem; }
        .confirm-buttons button { flex: 1; }
    </style>
</head>
<body>
    <header class="hero">
        <div class="container">
            <h1>ACSM Converter</h1>
            <p>Convert ACSM ebook tokens to DRM-free EPUB and PDF</p>
        </div>
    </header>

    <main class="container">
        <!-- Upload -->
        <section id="upload-section">
            <div class="upload-box">
                <div class="icon">&#128214;</div>
                <p>Select an <strong>.acsm</strong> file to begin conversion</p>
                <input type="file" id="file-input" accept=".acsm" hidden>
                <button class="btn-browse" onclick="document.getElementById('file-input').click()">Browse File…</button>
            </div>
        </section>

        <!-- Confirm -->
        <section id="confirm-section">
            <h3>Ready to Convert</h3>
            <p>File: <span class="confirm-filename" id="confirm-filename"></span></p>
            <p>This will download the ebook and remove DRM protection.</p>
            <div class="confirm-buttons">
                <button id="confirm-cancel" class="secondary outline">Cancel</button>
                <button id="confirm-start">Start Conversion</button>
            </div>
        </section>

        <!-- Progress -->
        <section id="progress-section">
            <h3>Converting: <span id="converting-name"></span></h3>
            <progress id="progress-bar" value="0" max="5" style="margin-bottom:1rem"></progress>
            <div id="steps"></div>
        </section>

        <!-- History -->
        {% if books %}
        <section>
            <h3>Previously Converted</h3>
            <div class="book-grid">
                {% for book in books %}
                <article class="book-card">
                    <div class="book-cover">
                        {% if book.cover %}
                        <img src="/cover/{{ book.cover }}" alt="{{ book.stem }} cover">
                        {% else %}
                        <span class="placeholder">&#128218;</span>
                        {% endif %}
                    </div>
                    <div class="book-info">
                        <h4>{{ book.stem }}</h4>
                        <div class="book-files">
                            {% for f in book.files %}
                            <div class="book-file">
                                <span class="file-badge {{ f.ext|lower }}">{{ f.ext }}</span>
                                <span class="file-size">{{ f.size }}</span>
                                <a href="/download/{{ f.name }}" class="btn-dl">Download</a>
                            </div>
                            {% endfor %}
                        </div>
                        {% if not book.has_epub %}
                        <div id="epub-action-{{ loop.index }}" data-stem="{{ book.stem }}">
                            <button class="btn-convert-epub" onclick="startEpubConvert('{{ book.stem }}', 'epub-action-{{ loop.index }}')">
                                Convert to EPUB
                            </button>
                        </div>
                        {% endif %}
                    </div>
                </article>
                {% endfor %}
            </div>
        </section>
        {% endif %}
    </main>

    <script>
        const fileInput = document.getElementById('file-input');
        const uploadSection = document.getElementById('upload-section');
        const confirmSection = document.getElementById('confirm-section');
        const confirmFilename = document.getElementById('confirm-filename');
        const confirmStart = document.getElementById('confirm-start');
        const confirmCancel = document.getElementById('confirm-cancel');
        const progressSection = document.getElementById('progress-section');
        const stepsDiv = document.getElementById('steps');
        const progressBar = document.getElementById('progress-bar');
        const convertingName = document.getElementById('converting-name');

        let pendingFilename = null;
        let elapsedTimer = null;
        let stepStartTime = null;
        const stepDivs = {};

        fileInput.addEventListener('change', () => {
            if (fileInput.files[0]) uploadFile(fileInput.files[0]);
        });

        confirmStart.addEventListener('click', () => {
            if (pendingFilename) startConversion(pendingFilename);
        });
        confirmCancel.addEventListener('click', () => {
            confirmSection.style.display = 'none';
            uploadSection.style.display = 'block';
            pendingFilename = null;
            fileInput.value = '';
        });

        async function uploadFile(file) {
            if (!file.name.endsWith('.acsm')) {
                alert('Please select an .acsm file');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            try {
                const resp = await fetch('/upload', { method: 'POST', body: formData });
                const data = await resp.json();
                if (data.error) { alert(data.error); return; }
                pendingFilename = data.filename;
                uploadSection.style.display = 'none';
                confirmFilename.textContent = data.filename;
                confirmSection.style.display = 'block';
            } catch (err) {
                alert('Upload failed: ' + err.message);
            }
        }

        let totalSteps = 5;
        let lastRenderedSteps = 0;

        async function startConversion(filename) {
            confirmSection.style.display = 'none';
            uploadSection.style.display = 'none';
            progressSection.style.display = 'block';
            convertingName.textContent = filename;
            stepsDiv.innerHTML = '';
            progressBar.value = 0;
            totalSteps = 5;
            lastRenderedSteps = 0;
            Object.keys(stepDivs).forEach(k => delete stepDivs[k]);

            let jobId;
            try {
                const resp = await fetch('/start-convert/' + encodeURIComponent(filename), { method: 'POST' });
                const text = await resp.text();
                let data;
                try { data = JSON.parse(text); } catch(e) {
                    addStep('error', 'Server error: ' + text.substring(0, 200), 'error');
                    return;
                }
                if (data.error) { alert(data.error); return; }
                jobId = data.job_id;
            } catch (err) {
                alert('Failed to start conversion: ' + err.message);
                return;
            }

            showActiveStep(1, totalSteps, 'Checking tools...');

            let pollCount = 0;
            const poller = setInterval(async () => {
                pollCount++;
                try {
                    const resp = await fetch('/job-status/' + encodeURIComponent(jobId));
                    const text = await resp.text();
                    let data;
                    try { data = JSON.parse(text); } catch(e) { return; }

                    for (let i = lastRenderedSteps; i < data.steps.length; i++) {
                        const s = data.steps[i];
                        if (s.step === 'done') {
                            Object.values(stepDivs).forEach(d => {
                                if (d.dataset.status === 'active') {
                                    d.dataset.status = 'done';
                                    const el = d.querySelector('.elapsed');
                                    if (el) el.remove();
                                }
                            });
                            stopElapsedTimer();
                            progressBar.value = totalSteps;
                            addStep('done', s.message, 'done');
                            clearInterval(poller);
                            setTimeout(() => { window.location.reload(); }, 2000);
                            return;
                        } else {
                            const stepNum = s.step;
                            if (stepDivs[stepNum]) {
                                stopElapsedTimer();
                                const div = stepDivs[stepNum];
                                div.dataset.status = 'done';
                                const el = div.querySelector('.elapsed');
                                if (el) el.remove();
                                div.childNodes[0].textContent = 'Step ' + stepNum + '/' + totalSteps + ': ' + s.message;
                            } else {
                                const div = document.createElement('div');
                                div.className = 'step';
                                div.dataset.status = 'done';
                                div.textContent = 'Step ' + stepNum + '/' + totalSteps + ': ' + s.message;
                                stepDivs[stepNum] = div;
                                stepsDiv.appendChild(div);
                            }
                            progressBar.value = stepNum;
                        }
                    }
                    lastRenderedSteps = data.steps.length;

                    if (data.status === 'running' && data.current_step > 0) {
                        if (!stepDivs[data.current_step]) {
                            showActiveStep(data.current_step, totalSteps, data.current_label);
                        }
                    }

                    if (data.status === 'error') {
                        Object.values(stepDivs).forEach(d => {
                            if (d.dataset.status === 'active') {
                                d.dataset.status = 'error';
                                const el = d.querySelector('.elapsed');
                                if (el) el.remove();
                            }
                        });
                        stopElapsedTimer();
                        addStep('error', data.error, 'error');
                        clearInterval(poller);
                        setTimeout(() => { uploadSection.style.display = 'block'; }, 3000);
                    }
                } catch (err) {
                    // network error — keep polling
                }
            }, 2000);
        }

        function showActiveStep(stepNum, total, label) {
            stopElapsedTimer();
            const div = document.createElement('div');
            div.className = 'step';
            div.dataset.status = 'active';
            const textNode = document.createTextNode('Step ' + stepNum + '/' + total + ': ' + label + ' ');
            div.appendChild(textNode);
            stepDivs[stepNum] = div;

            const span = document.createElement('span');
            span.className = 'elapsed';
            div.appendChild(span);
            stepStartTime = Date.now();
            elapsedTimer = setInterval(() => {
                const secs = Math.floor((Date.now() - stepStartTime) / 1000);
                span.textContent = formatElapsed(secs);
            }, 1000);

            stepsDiv.appendChild(div);
        }

        function stopElapsedTimer() {
            if (elapsedTimer) { clearInterval(elapsedTimer); elapsedTimer = null; }
        }

        function formatElapsed(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return m > 0 ? m + 'm ' + s + 's' : s + 's';
        }

        function addStep(key, text, status) {
            const div = document.createElement('div');
            div.className = 'step';
            div.dataset.status = status;
            div.textContent = text;
            stepsDiv.appendChild(div);
        }

        // ─── EPUB Conversion ─────────────────────────────────────────────

        async function startEpubConvert(stem, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            try {
                const resp = await fetch('/convert-epub/' + encodeURIComponent(stem), { method: 'POST' });
                const data = await resp.json();
                if (data.status !== 'started') {
                    alert(data.message || 'Could not start conversion');
                    return;
                }
            } catch (err) {
                alert('Failed to start EPUB conversion: ' + err.message);
                return;
            }

            const startTime = Date.now();
            container.innerHTML =
                '<div class="epub-converting">'
                + '<span class="mini-spinner"></span>'
                + '<span>Converting to EPUB... <span class="epub-elapsed">0s</span></span>'
                + '<button class="btn-stop" onclick="stopEpubConvert(\'' + stem + '\', \'' + containerId + '\')">Stop</button>'
                + '</div>';

            const elapsedSpan = container.querySelector('.epub-elapsed');
            const timer = setInterval(() => {
                const secs = Math.floor((Date.now() - startTime) / 1000);
                elapsedSpan.textContent = formatElapsed(secs);
            }, 1000);

            const poller = setInterval(async () => {
                try {
                    const resp = await fetch('/convert-epub-status/' + encodeURIComponent(stem));
                    const data = await resp.json();
                    if (data.status === 'done') {
                        clearInterval(timer);
                        clearInterval(poller);
                        window.location.reload();
                    } else if (data.status === 'error') {
                        clearInterval(timer);
                        clearInterval(poller);
                        container.innerHTML =
                            '<div style="color:#c62828; font-size:0.85rem; margin-top:0.5rem;">'
                            + 'EPUB conversion failed. '
                            + '<button class="btn-convert-epub" onclick="startEpubConvert(\'' + stem + '\', \'' + containerId + '\')">Retry</button>'
                            + '</div>';
                    } else if (data.status === 'not_found') {
                        clearInterval(timer);
                        clearInterval(poller);
                        container.innerHTML =
                            '<button class="btn-convert-epub" onclick="startEpubConvert(\'' + stem + '\', \'' + containerId + '\')">Convert to EPUB</button>';
                    }
                } catch (err) {
                    // keep polling
                }
            }, 3000);

            container._epubTimer = timer;
            container._epubPoller = poller;
        }

        async function stopEpubConvert(stem, containerId) {
            const container = document.getElementById(containerId);
            if (container._epubTimer) clearInterval(container._epubTimer);
            if (container._epubPoller) clearInterval(container._epubPoller);

            try {
                await fetch('/stop-convert/' + encodeURIComponent(stem), { method: 'POST' });
            } catch (err) { /* ignore */ }

            container.innerHTML =
                '<button class="btn-convert-epub" onclick="startEpubConvert(\'' + stem + '\', \'' + containerId + '\')">Convert to EPUB</button>';
        }
    </script>
</body>
</html>
